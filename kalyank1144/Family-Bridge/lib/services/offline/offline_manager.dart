import 'package:hive_flutter/hive_flutter.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:crypto/crypto.dart';
import 'dart:convert';
import '../../models/hive/user_model.dart';
import '../../models/hive/health_data_model.dart';
import '../../models/hive/medication_model.dart';
import '../../models/hive/message_model.dart';
import '../../models/hive/appointment_model.dart';
import '../../models/sync/sync_item.dart';

class OfflineManager {
  static const String _encryptionKeyName = 'hive_encryption_key';
  static const FlutterSecureStorage _secureStorage = FlutterSecureStorage();
  
  // Box names
  static const String usersBox = 'users_box';
  static const String messagesBox = 'messages_box';
  static const String healthDataBox = 'health_data_box';
  static const String medicationsBox = 'medications_box';
  static const String contactsBox = 'contacts_box';
  static const String appointmentsBox = 'appointments_box';
  static const String syncQueueBox = 'sync_queue_box';
  static const String cacheBox = 'cache_box';
  static const String settingsBox = 'settings_box';

  static late Box<UserModel> _usersBox;
  static late Box<MessageModel> _messagesBox;
  static late Box<HealthDataModel> _healthDataBox;
  static late Box<MedicationModel> _medicationsBox;
  static late Box<AppointmentModel> _appointmentsBox;
  static late Box<SyncItem> _syncQueueBox;
  static late LazyBox _cacheBox;
  static late Box _settingsBox;

  static bool _isInitialized = false;

  static Future<void> initialize() async {
    if (_isInitialized) return;

    await Hive.initFlutter();
    
    // Get or generate encryption key
    final encryptionKey = await _getEncryptionKey();
    
    // Register adapters
    _registerAdapters();
    
    // Open encrypted boxes for sensitive data
    _usersBox = await Hive.openBox<UserModel>(
      usersBox,
      encryptionCipher: HiveAesCipher(encryptionKey),
    );
    
    _messagesBox = await Hive.openBox<MessageModel>(
      messagesBox,
      encryptionCipher: HiveAesCipher(encryptionKey),
    );
    
    _healthDataBox = await Hive.openBox<HealthDataModel>(
      healthDataBox,
      encryptionCipher: HiveAesCipher(encryptionKey),
    );
    
    _medicationsBox = await Hive.openBox<MedicationModel>(
      medicationsBox,
      encryptionCipher: HiveAesCipher(encryptionKey),
    );
    
    _appointmentsBox = await Hive.openBox<AppointmentModel>(
      appointmentsBox,
      encryptionCipher: HiveAesCipher(encryptionKey),
    );
    
    _syncQueueBox = await Hive.openBox<SyncItem>(
      syncQueueBox,
      encryptionCipher: HiveAesCipher(encryptionKey),
    );
    
    // Open lazy box for large data
    _cacheBox = await Hive.openLazyBox(
      cacheBox,
      encryptionCipher: HiveAesCipher(encryptionKey),
    );
    
    // Open regular box for settings
    _settingsBox = await Hive.openBox(settingsBox);
    
    _isInitialized = true;
    
    // Run compaction strategy
    await _runCompaction();
  }

  static void _registerAdapters() {
    if (!Hive.isAdapterRegistered(0)) {
      // Register all type adapters
      // Note: In production, these would be generated by build_runner
      // For now, we'll need to manually implement or generate them
    }
  }

  static Future<List<int>> _getEncryptionKey() async {
    String? base64Key = await _secureStorage.read(key: _encryptionKeyName);
    
    if (base64Key == null) {
      // Generate new key
      final key = Hive.generateSecureKey();
      base64Key = base64.encode(key);
      await _secureStorage.write(key: _encryptionKeyName, value: base64Key);
      return key;
    }
    
    return base64.decode(base64Key);
  }

  static Future<void> _runCompaction() async {
    // Compact boxes if they're too large
    final boxes = [
      _usersBox,
      _messagesBox,
      _healthDataBox,
      _medicationsBox,
      _appointmentsBox,
      _syncQueueBox,
    ];
    
    for (final box in boxes) {
      if (box.length > 1000) {
        await box.compact();
      }
    }
  }

  // Elder essentials
  static Future<ElderOfflineData> getElderEssentials(String userId) async {
    final user = _usersBox.get(userId);
    final medications = _medicationsBox.values
        .where((m) => m.userId == userId && m.isActive)
        .toList();
    final recentMessages = _getRecentMessages(userId, limit: 50);
    final healthData = _getRecentHealthData(userId, days: 7);
    final upcomingAppointments = _getUpcomingAppointments(userId, days: 30);
    
    // Get emergency contacts from settings
    final emergencyContacts = _settingsBox.get('emergency_contacts_$userId') ?? [];
    
    return ElderOfflineData(
      user: user,
      medications: medications,
      recentMessages: recentMessages,
      healthData: healthData,
      appointments: upcomingAppointments,
      emergencyContacts: emergencyContacts,
    );
  }

  // Caregiver essentials
  static Future<CaregiverOfflineData> getCaregiverEssentials(String userId) async {
    final user = _usersBox.get(userId);
    final familyMembers = await _getFamilyMembers(userId);
    final allHealthData = <String, List<HealthDataModel>>{};
    final allAppointments = <String, List<AppointmentModel>>{};
    
    for (final member in familyMembers) {
      allHealthData[member.userId] = _getRecentHealthData(member.userId, days: 7);
      allAppointments[member.userId] = _getUpcomingAppointments(member.userId, days: 30);
    }
    
    final careNotes = _settingsBox.get('care_notes_$userId') ?? {};
    
    return CaregiverOfflineData(
      user: user,
      familyMembers: familyMembers,
      familyHealthData: allHealthData,
      familyAppointments: allAppointments,
      careNotes: careNotes,
    );
  }

  // Youth essentials
  static Future<YouthOfflineData> getYouthEssentials(String userId) async {
    final user = _usersBox.get(userId);
    final points = _settingsBox.get('points_$userId') ?? 0;
    final achievements = _settingsBox.get('achievements_$userId') ?? [];
    final cachedStories = await _getCachedStories();
    final gameProgress = _settingsBox.get('game_progress_$userId') ?? {};
    final familyPhotos = await _getCachedFamilyPhotos();
    
    return YouthOfflineData(
      user: user,
      points: points,
      achievements: achievements,
      cachedStories: cachedStories,
      gameProgress: gameProgress,
      familyPhotos: familyPhotos,
    );
  }

  static List<MessageModel> _getRecentMessages(String userId, {int limit = 100}) {
    final messages = _messagesBox.values
        .where((m) => m.senderId == userId || m.recipientId == userId)
        .toList();
    
    messages.sort((a, b) => b.timestamp.compareTo(a.timestamp));
    
    return messages.take(limit).toList();
  }

  static List<HealthDataModel> _getRecentHealthData(String userId, {int days = 7}) {
    final cutoffDate = DateTime.now().subtract(Duration(days: days));
    
    return _healthDataBox.values
        .where((h) => h.userId == userId && h.recordedAt.isAfter(cutoffDate))
        .toList()
      ..sort((a, b) => b.recordedAt.compareTo(a.recordedAt));
  }

  static List<AppointmentModel> _getUpcomingAppointments(String userId, {int days = 30}) {
    final endDate = DateTime.now().add(Duration(days: days));
    
    return _appointmentsBox.values
        .where((a) => 
            a.userId == userId && 
            a.isUpcoming && 
            a.dateTime.isBefore(endDate))
        .toList()
      ..sort((a, b) => a.dateTime.compareTo(b.dateTime));
  }

  static Future<List<UserModel>> _getFamilyMembers(String userId) async {
    final user = _usersBox.get(userId);
    if (user?.familyId == null) return [];
    
    return _usersBox.values
        .where((u) => u.familyId == user!.familyId && u.userId != userId)
        .toList();
  }

  static Future<List<Map<String, dynamic>>> _getCachedStories() async {
    final stories = await _cacheBox.get('cached_stories') ?? [];
    return List<Map<String, dynamic>>.from(stories);
  }

  static Future<List<String>> _getCachedFamilyPhotos() async {
    final photos = await _cacheBox.get('family_photos') ?? [];
    return List<String>.from(photos);
  }

  // Save methods
  static Future<void> saveUser(UserModel user) async {
    await _usersBox.put(user.userId, user);
  }

  static Future<void> saveMessage(MessageModel message) async {
    await _messagesBox.put(message.id, message);
    
    // Keep only last 100 messages per conversation
    await _pruneMessages();
  }

  static Future<void> saveHealthData(HealthDataModel data) async {
    await _healthDataBox.put(data.id, data);
    
    // Keep only last 7 days of data
    await _pruneHealthData();
  }

  static Future<void> saveMedication(MedicationModel medication) async {
    await _medicationsBox.put(medication.id, medication);
  }

  static Future<void> saveAppointment(AppointmentModel appointment) async {
    await _appointmentsBox.put(appointment.id, appointment);
  }

  static Future<void> _pruneMessages() async {
    if (_messagesBox.length > 500) {
      final messages = _messagesBox.values.toList()
        ..sort((a, b) => b.timestamp.compareTo(a.timestamp));
      
      final toDelete = messages.skip(100).map((m) => m.id);
      await _messagesBox.deleteAll(toDelete);
    }
  }

  static Future<void> _pruneHealthData() async {
    final cutoffDate = DateTime.now().subtract(const Duration(days: 30));
    final toDelete = _healthDataBox.values
        .where((h) => h.recordedAt.isBefore(cutoffDate))
        .map((h) => h.id);
    
    await _healthDataBox.deleteAll(toDelete);
  }

  static Future<void> clearAll() async {
    await _usersBox.clear();
    await _messagesBox.clear();
    await _healthDataBox.clear();
    await _medicationsBox.clear();
    await _appointmentsBox.clear();
    await _syncQueueBox.clear();
    await _cacheBox.clear();
    await _settingsBox.clear();
  }

  static Future<void> close() async {
    await _usersBox.close();
    await _messagesBox.close();
    await _healthDataBox.close();
    await _medicationsBox.close();
    await _appointmentsBox.close();
    await _syncQueueBox.close();
    await _cacheBox.close();
    await _settingsBox.close();
    _isInitialized = false;
  }
}

// Data classes for offline essentials
class ElderOfflineData {
  final UserModel? user;
  final List<MedicationModel> medications;
  final List<MessageModel> recentMessages;
  final List<HealthDataModel> healthData;
  final List<AppointmentModel> appointments;
  final List<dynamic> emergencyContacts;

  ElderOfflineData({
    this.user,
    required this.medications,
    required this.recentMessages,
    required this.healthData,
    required this.appointments,
    required this.emergencyContacts,
  });
}

class CaregiverOfflineData {
  final UserModel? user;
  final List<UserModel> familyMembers;
  final Map<String, List<HealthDataModel>> familyHealthData;
  final Map<String, List<AppointmentModel>> familyAppointments;
  final Map<String, dynamic> careNotes;

  CaregiverOfflineData({
    this.user,
    required this.familyMembers,
    required this.familyHealthData,
    required this.familyAppointments,
    required this.careNotes,
  });
}

class YouthOfflineData {
  final UserModel? user;
  final int points;
  final List<dynamic> achievements;
  final List<Map<String, dynamic>> cachedStories;
  final Map<String, dynamic> gameProgress;
  final List<String> familyPhotos;

  YouthOfflineData({
    this.user,
    required this.points,
    required this.achievements,
    required this.cachedStories,
    required this.gameProgress,
    required this.familyPhotos,
  });
}